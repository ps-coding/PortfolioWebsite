{"ast":null,"code":"import { ɵgetAllInstancesOf, ɵisAnalyticsSupportedFactory, ɵzoneWrap, VERSION, ɵgetDefaultInstanceOf, ɵAngularFireSchedulers } from '@angular/fire';\nimport { timer, from, of } from 'rxjs';\nimport { concatMap, distinct, filter, switchMap, map, groupBy, mergeMap, distinctUntilChanged, startWith, pairwise } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, InjectionToken, APP_INITIALIZER, NgModule, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { registerVersion } from 'firebase/app';\nimport { __awaiter } from 'tslib';\nimport * as i1$1 from '@angular/router';\nimport { ActivationEnd, ɵEmptyOutletComponent } from '@angular/router';\nimport * as i2 from '@angular/platform-browser';\nimport { getAnalytics as getAnalytics$1, initializeAnalytics as initializeAnalytics$1, logEvent as logEvent$1, setAnalyticsCollectionEnabled as setAnalyticsCollectionEnabled$1, setCurrentScreen as setCurrentScreen$1, settings as settings$1, setUserId as setUserId$1, setUserProperties as setUserProperties$1 } from 'firebase/analytics';\nexport * from 'firebase/analytics';\nimport * as i1 from '@angular/fire/auth';\nimport { authState } from '@angular/fire/auth';\n\nclass Analytics {\n  constructor(analytics) {\n    return analytics;\n  }\n\n}\n\nconst ANALYTICS_PROVIDER_NAME = 'analytics';\n\nclass AnalyticsInstances {\n  constructor() {\n    return ɵgetAllInstancesOf(ANALYTICS_PROVIDER_NAME);\n  }\n\n}\n\nconst analyticInstance$ = /*#__PURE__*/ /*#__PURE__*/timer(0, 300).pipe( /*#__PURE__*/concatMap(() => from(ɵgetAllInstancesOf(ANALYTICS_PROVIDER_NAME))), /*#__PURE__*/distinct());\nconst isSupported = ɵisAnalyticsSupportedFactory.async; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n\nconst getAnalytics = /*#__PURE__*/ɵzoneWrap(getAnalytics$1, true);\nconst initializeAnalytics = /*#__PURE__*/ɵzoneWrap(initializeAnalytics$1, true);\nconst logEvent = /*#__PURE__*/ɵzoneWrap(logEvent$1, true);\nconst setAnalyticsCollectionEnabled = /*#__PURE__*/ɵzoneWrap(setAnalyticsCollectionEnabled$1, true);\nconst setCurrentScreen = /*#__PURE__*/ɵzoneWrap(setCurrentScreen$1, true);\nconst settings = /*#__PURE__*/ɵzoneWrap(settings$1, true);\nconst setUserId = /*#__PURE__*/ɵzoneWrap(setUserId$1, true);\nconst setUserProperties = /*#__PURE__*/ɵzoneWrap(setUserProperties$1, true);\nlet UserTrackingService = /*#__PURE__*/(() => {\n  class UserTrackingService {\n    constructor(auth, zone, injector) {\n      this.disposables = [];\n      registerVersion('angularfire', VERSION.full, 'user-tracking');\n      let resolveInitialized;\n      this.initialized = zone.runOutsideAngular(() => new Promise(resolve => {\n        resolveInitialized = resolve;\n      })); // The APP_INITIALIZER that is making isSupported() sync for the sake of convenient DI\n      // may not be done when services are initialized. Guard the functionality by first ensuring\n      // that the (global) promise has resolved, then get Analytics from the injector.\n\n      isSupported().then(() => {\n        const analytics = injector.get(Analytics);\n\n        if (analytics) {\n          this.disposables = [// TODO add credential tracking back in\n          authState(auth).subscribe(user => {\n            setUserId(analytics, user === null || user === void 0 ? void 0 : user.uid);\n            resolveInitialized();\n          })];\n        } else {\n          resolveInitialized();\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this.disposables.forEach(it => it.unsubscribe());\n    }\n\n  }\n\n  UserTrackingService.ɵfac = function UserTrackingService_Factory(t) {\n    return new (t || UserTrackingService)(i0.ɵɵinject(i1.Auth), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.Injector));\n  };\n\n  UserTrackingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserTrackingService,\n    factory: UserTrackingService.ɵfac\n  });\n  return UserTrackingService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst FIREBASE_EVENT_ORIGIN_KEY = 'firebase_event_origin';\nconst FIREBASE_PREVIOUS_SCREEN_CLASS_KEY = 'firebase_previous_class';\nconst FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY = 'firebase_previous_id';\nconst FIREBASE_PREVIOUS_SCREEN_NAME_KEY = 'firebase_previous_screen';\nconst FIREBASE_SCREEN_CLASS_KEY = 'firebase_screen_class';\nconst FIREBASE_SCREEN_INSTANCE_ID_KEY = 'firebase_screen_id';\nconst FIREBASE_SCREEN_NAME_KEY = 'firebase_screen';\nconst OUTLET_KEY = 'outlet';\nconst PAGE_PATH_KEY = 'page_path';\nconst PAGE_TITLE_KEY = 'page_title';\nconst SCREEN_CLASS_KEY = 'screen_class';\nconst SCREEN_NAME_KEY = 'screen_name';\nconst SCREEN_VIEW_EVENT = 'screen_view';\nconst EVENT_ORIGIN_AUTO = 'auto';\nconst SCREEN_INSTANCE_DELIMITER = '#'; // this is an INT64 in iOS/Android but use INT32 cause javascript\n\nlet nextScreenInstanceID = /*#__PURE__*/Math.floor( /*#__PURE__*/Math.random() * ( /*#__PURE__*/Math.pow(2, 32) - 1)) - /*#__PURE__*/Math.pow(2, 31);\nconst knownScreenInstanceIDs = {};\n\nconst getScreenInstanceID = params => {\n  // unique the screen class against the outlet name\n  const screenInstanceKey = [params[SCREEN_CLASS_KEY], params[OUTLET_KEY]].join(SCREEN_INSTANCE_DELIMITER);\n\n  if (knownScreenInstanceIDs.hasOwnProperty(screenInstanceKey)) {\n    return knownScreenInstanceIDs[screenInstanceKey];\n  } else {\n    const ret = nextScreenInstanceID++;\n    knownScreenInstanceIDs[screenInstanceKey] = ret;\n    return ret;\n  }\n};\n\nconst ɵscreenViewEvent = (router, title, componentFactoryResolver) => {\n  const activationEndEvents = router.events.pipe(filter(e => e instanceof ActivationEnd));\n  return activationEndEvents.pipe(switchMap(activationEnd => {\n    var _a; // router parseUrl is having trouble with outlets when they're empty\n    // e.g, /asdf/1(bob://sally:asdf), so put another slash in when empty\n\n\n    const urlTree = router.parseUrl(router.url.replace(/(?:\\().+(?:\\))/g, a => a.replace('://', ':///')));\n    const pagePath = ((_a = urlTree.root.children[activationEnd.snapshot.outlet]) === null || _a === void 0 ? void 0 : _a.toString()) || '';\n    const actualSnapshot = router.routerState.root.children.map(it => it).find(it => it.outlet === activationEnd.snapshot.outlet);\n\n    if (!actualSnapshot) {\n      return of(null);\n    }\n\n    let actualDeep = actualSnapshot;\n\n    while (actualDeep.firstChild) {\n      actualDeep = actualDeep.firstChild;\n    }\n\n    const screenName = actualDeep.pathFromRoot.map(s => {\n      var _a;\n\n      return (_a = s.routeConfig) === null || _a === void 0 ? void 0 : _a.path;\n    }).filter(it => it).join('/') || '/';\n    const params = {\n      [SCREEN_NAME_KEY]: screenName,\n      [PAGE_PATH_KEY]: `/${pagePath}`,\n      [FIREBASE_EVENT_ORIGIN_KEY]: EVENT_ORIGIN_AUTO,\n      [FIREBASE_SCREEN_NAME_KEY]: screenName,\n      [OUTLET_KEY]: activationEnd.snapshot.outlet\n    };\n\n    if (title) {\n      params[PAGE_TITLE_KEY] = title.getTitle();\n    }\n\n    let component = actualSnapshot.component;\n\n    if (component) {\n      if (component === ɵEmptyOutletComponent) {\n        let deepSnapshot = activationEnd.snapshot; // TODO when might there be mutple children, different outlets? explore\n\n        while (deepSnapshot.firstChild) {\n          deepSnapshot = deepSnapshot.firstChild;\n        }\n\n        component = deepSnapshot.component;\n      }\n    } else {\n      component = activationEnd.snapshot.component;\n    }\n\n    if (typeof component === 'string') {\n      return of(Object.assign(Object.assign({}, params), {\n        [SCREEN_CLASS_KEY]: component\n      }));\n    } else if (component) {\n      const componentFactory = componentFactoryResolver.resolveComponentFactory(component);\n      return of(Object.assign(Object.assign({}, params), {\n        [SCREEN_CLASS_KEY]: componentFactory.selector\n      }));\n    } // lazy loads cause extra activations, ignore\n\n\n    return of(null);\n  }), filter(it => !!it), map(params => Object.assign({\n    [FIREBASE_SCREEN_CLASS_KEY]: params[SCREEN_CLASS_KEY],\n    [FIREBASE_SCREEN_INSTANCE_ID_KEY]: getScreenInstanceID(params)\n  }, params)), groupBy(it => it[OUTLET_KEY]), mergeMap(it => it.pipe(distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b)), startWith(undefined), pairwise(), map(([prior, current]) => prior ? Object.assign({\n    [FIREBASE_PREVIOUS_SCREEN_CLASS_KEY]: prior[SCREEN_CLASS_KEY],\n    [FIREBASE_PREVIOUS_SCREEN_NAME_KEY]: prior[SCREEN_NAME_KEY],\n    [FIREBASE_PREVIOUS_SCREEN_INSTANCE_ID_KEY]: prior[FIREBASE_SCREEN_INSTANCE_ID_KEY]\n  }, current) : current))));\n};\n\nlet ScreenTrackingService = /*#__PURE__*/(() => {\n  class ScreenTrackingService {\n    constructor(router, title, componentFactoryResolver, zone, userTrackingService, injector) {\n      registerVersion('angularfire', VERSION.full, 'screen-tracking'); // The APP_INITIALIZER that is making isSupported() sync for the sake of convenient DI\n      // may not be done when services are initialized. Guard the functionality by first ensuring\n      // that the (global) promise has resolved, then get Analytics from the injector.\n\n      isSupported().then(() => {\n        const analytics = injector.get(Analytics);\n\n        if (!router || !analytics) {\n          return;\n        }\n\n        zone.runOutsideAngular(() => {\n          this.disposable = ɵscreenViewEvent(router, title, componentFactoryResolver).pipe(switchMap(params => __awaiter(this, void 0, void 0, function* () {\n            if (userTrackingService) {\n              yield userTrackingService.initialized;\n            }\n\n            return logEvent(analytics, SCREEN_VIEW_EVENT, params);\n          }))).subscribe();\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.disposable) {\n        this.disposable.unsubscribe();\n      }\n    }\n\n  }\n\n  ScreenTrackingService.ɵfac = function ScreenTrackingService_Factory(t) {\n    return new (t || ScreenTrackingService)(i0.ɵɵinject(i1$1.Router, 8), i0.ɵɵinject(i2.Title, 8), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(UserTrackingService, 8), i0.ɵɵinject(i0.Injector));\n  };\n\n  ScreenTrackingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScreenTrackingService,\n    factory: ScreenTrackingService.ɵfac\n  });\n  return ScreenTrackingService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst PROVIDED_ANALYTICS_INSTANCES = /*#__PURE__*/new InjectionToken('angularfire2.analytics-instances');\n\nfunction defaultAnalyticsInstanceFactory(provided, defaultApp) {\n  if (!ɵisAnalyticsSupportedFactory.sync()) {\n    return null;\n  }\n\n  const defaultAnalytics = ɵgetDefaultInstanceOf(ANALYTICS_PROVIDER_NAME, provided, defaultApp);\n  return defaultAnalytics && new Analytics(defaultAnalytics);\n}\n\nfunction analyticsInstanceFactory(fn) {\n  return (zone, injector) => {\n    if (!ɵisAnalyticsSupportedFactory.sync()) {\n      return null;\n    }\n\n    const analytics = zone.runOutsideAngular(() => fn(injector));\n    return new Analytics(analytics);\n  };\n}\n\nconst ANALYTICS_INSTANCES_PROVIDER = {\n  provide: AnalyticsInstances,\n  deps: [[/*#__PURE__*/new Optional(), PROVIDED_ANALYTICS_INSTANCES]]\n};\nconst DEFAULT_ANALYTICS_INSTANCE_PROVIDER = {\n  provide: Analytics,\n  useFactory: defaultAnalyticsInstanceFactory,\n  deps: [[/*#__PURE__*/new Optional(), PROVIDED_ANALYTICS_INSTANCES], FirebaseApp]\n};\nlet AnalyticsModule = /*#__PURE__*/(() => {\n  class AnalyticsModule {\n    constructor(_screenTrackingService, _userTrackingService) {\n      registerVersion('angularfire', VERSION.full, 'analytics');\n    }\n\n  }\n\n  AnalyticsModule.ɵfac = function AnalyticsModule_Factory(t) {\n    return new (t || AnalyticsModule)(i0.ɵɵinject(ScreenTrackingService, 8), i0.ɵɵinject(UserTrackingService, 8));\n  };\n\n  AnalyticsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AnalyticsModule\n  });\n  AnalyticsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_ANALYTICS_INSTANCE_PROVIDER, ANALYTICS_INSTANCES_PROVIDER, {\n      provide: APP_INITIALIZER,\n      useValue: ɵisAnalyticsSupportedFactory.async,\n      multi: true\n    }]\n  });\n  return AnalyticsModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction provideAnalytics(fn, ...deps) {\n  return {\n    ngModule: AnalyticsModule,\n    providers: [{\n      provide: PROVIDED_ANALYTICS_INSTANCES,\n      useFactory: analyticsInstanceFactory(fn),\n      multi: true,\n      deps: [NgZone, Injector, ɵAngularFireSchedulers, FirebaseApps, ...deps]\n    }]\n  };\n}\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Analytics, AnalyticsInstances, AnalyticsModule, ScreenTrackingService, UserTrackingService, analyticInstance$, getAnalytics, initializeAnalytics, isSupported, logEvent, provideAnalytics, setAnalyticsCollectionEnabled, setCurrentScreen, setUserId, setUserProperties, settings, ɵscreenViewEvent }; //# sourceMappingURL=angular-fire-analytics.js.map","map":null,"metadata":{},"sourceType":"module"}