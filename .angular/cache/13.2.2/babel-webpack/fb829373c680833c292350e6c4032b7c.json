{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Optional, Inject, NgModule } from '@angular/core';\nimport { of, EMPTY } from 'rxjs';\nimport { isPlatformBrowser, isPlatformServer } from '@angular/common';\nimport { observeOn, switchMap, map, shareReplay } from 'rxjs/operators';\nimport * as i2 from '@angular/fire';\nimport { VERSION } from '@angular/fire';\nimport * as i1 from '@angular/fire/compat';\nimport { ɵcacheInstance, ɵlazySDKProxy, ɵapplyMixins } from '@angular/fire/compat';\nimport { isSupported } from 'firebase/analytics';\nimport * as i2$2 from '@angular/router';\nimport * as i3 from '@angular/platform-browser';\nimport * as i2$1 from '@angular/fire/compat/auth';\nimport firebase from 'firebase/compat/app';\nimport { ɵscreenViewEvent } from '@angular/fire/analytics'; // DO NOT MODIFY, this file is autogenerated by tools/build.ts\n// Export a null object with the same keys as firebase/compat/analytics, so Proxy can work with proxy-polyfill in Internet Explorer\n\nconst proxyPolyfillCompat = {\n  app: null,\n  logEvent: null,\n  setCurrentScreen: null,\n  setUserId: null,\n  setUserProperties: null,\n  setAnalyticsCollectionEnabled: null\n};\nconst COLLECTION_ENABLED = /*#__PURE__*/new InjectionToken('angularfire2.analytics.analyticsCollectionEnabled');\nconst APP_VERSION = /*#__PURE__*/new InjectionToken('angularfire2.analytics.appVersion');\nconst APP_NAME = /*#__PURE__*/new InjectionToken('angularfire2.analytics.appName');\nconst DEBUG_MODE = /*#__PURE__*/new InjectionToken('angularfire2.analytics.debugMode');\nconst CONFIG = /*#__PURE__*/new InjectionToken('angularfire2.analytics.config');\nconst APP_NAME_KEY = 'app_name';\nconst APP_VERSION_KEY = 'app_version';\nconst DEBUG_MODE_KEY = 'debug_mode';\nconst GTAG_CONFIG_COMMAND = 'config';\nconst GTAG_FUNCTION_NAME = 'gtag'; // TODO rename these\n\nconst DATA_LAYER_NAME = 'dataLayer';\nconst SEND_TO_KEY = 'send_to';\nlet AngularFireAnalytics = /*#__PURE__*/(() => {\n  class AngularFireAnalytics {\n    constructor(app, analyticsCollectionEnabled, providedAppVersion, providedAppName, debugModeEnabled, providedConfig, // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers) {\n      this.analyticsInitialized = new Promise(() => {});\n\n      if (isPlatformBrowser(platformId)) {\n        window[DATA_LAYER_NAME] = window[DATA_LAYER_NAME] || []; // It turns out we can't rely on the measurementId in the Firebase config JSON\n        // this identifier is not stable. firebase/analytics does a call to get a fresh value\n        // falling back on the one in the config. Rather than do that ourselves we should listen\n        // on our gtag function for a analytics config command\n        // e.g, ['config', measurementId, { origin: 'firebase', firebase_id }]\n\n        const parseMeasurementId = (...args) => {\n          if (args[0] === 'config' && args[2].origin === 'firebase') {\n            this.measurementId = args[1];\n            return true;\n          } else {\n            return false;\n          }\n        };\n\n        const patchGtag = fn => {\n          window[GTAG_FUNCTION_NAME] = (...args) => {\n            if (fn) {\n              fn(...args);\n            } // Inject app_name and app_version into events\n            // TODO(jamesdaniels): I'm doing this as documented but it's still not\n            //   showing up in the console. Investigate. Guessing it's just part of the\n            //   whole GA4 transition mess.\n\n\n            if (args[0] === 'event' && args[2][SEND_TO_KEY] === this.measurementId) {\n              if (providedAppName) {\n                args[2][APP_NAME_KEY] = providedAppName;\n              }\n\n              if (providedAppVersion) {\n                args[2][APP_VERSION_KEY] = providedAppVersion;\n              }\n            }\n\n            if (debugModeEnabled && typeof console !== 'undefined') {\n              // tslint:disable-next-line:no-console\n              console.info(...args);\n            }\n            /**\n             * According to the gtag documentation, this function that defines a custom data layer cannot be\n             * an arrow function because 'arguments' is not an array. It is actually an object that behaves\n             * like an array and contains more information then just indexes. Transforming this into arrow function\n             * caused issue #2505 where analytics no longer sent any data.\n             */\n            // tslint:disable-next-line: only-arrow-functions\n\n\n            (function (..._args) {\n              window[DATA_LAYER_NAME].push(arguments);\n            })(...args);\n          };\n        }; // Unclear if we still need to but I was running into config/events I passed\n        // to gtag before ['js' timestamp] weren't getting parsed, so let's make a promise\n        // that resolves when firebase/analytics has configured gtag.js that we wait on\n        // before sending anything\n\n\n        const firebaseAnalyticsAlreadyInitialized = window[DATA_LAYER_NAME].some(parseMeasurementId);\n\n        if (firebaseAnalyticsAlreadyInitialized) {\n          this.analyticsInitialized = Promise.resolve();\n          patchGtag();\n        } else {\n          this.analyticsInitialized = new Promise(resolve => {\n            patchGtag((...args) => {\n              if (parseMeasurementId(...args)) {\n                resolve();\n              }\n            });\n          });\n        }\n\n        if (providedConfig) {\n          this.updateConfig(providedConfig);\n        }\n\n        if (debugModeEnabled) {\n          this.updateConfig({\n            [DEBUG_MODE_KEY]: 1\n          });\n        }\n      } else {\n        this.analyticsInitialized = Promise.resolve();\n      }\n\n      const analytics = of(undefined).pipe(observeOn(schedulers.outsideAngular), switchMap(isSupported), switchMap(supported => supported ? zone.runOutsideAngular(() => import('firebase/compat/analytics')) : EMPTY), map(() => {\n        return ɵcacheInstance(`analytics`, 'AngularFireAnalytics', app.name, () => {\n          const analytics = app.analytics();\n\n          if (analyticsCollectionEnabled === false) {\n            analytics.setAnalyticsCollectionEnabled(false);\n          }\n\n          return analytics;\n        }, [app, analyticsCollectionEnabled, providedConfig, debugModeEnabled]);\n      }), shareReplay({\n        bufferSize: 1,\n        refCount: false\n      }));\n      return ɵlazySDKProxy(this, analytics, zone);\n    }\n\n    updateConfig(config) {\n      return __awaiter(this, void 0, void 0, function* () {\n        yield this.analyticsInitialized;\n        window[GTAG_FUNCTION_NAME](GTAG_CONFIG_COMMAND, this.measurementId, Object.assign(Object.assign({}, config), {\n          update: true\n        }));\n      });\n    }\n\n  }\n\n  AngularFireAnalytics.ɵfac = function AngularFireAnalytics_Factory(t) {\n    return new (t || AngularFireAnalytics)(i0.ɵɵinject(i1.FirebaseApp), i0.ɵɵinject(COLLECTION_ENABLED, 8), i0.ɵɵinject(APP_VERSION, 8), i0.ɵɵinject(APP_NAME, 8), i0.ɵɵinject(DEBUG_MODE, 8), i0.ɵɵinject(CONFIG, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i2.ɵAngularFireSchedulers));\n  };\n\n  AngularFireAnalytics.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireAnalytics,\n    factory: AngularFireAnalytics.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireAnalytics;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*#__PURE__*/\nɵapplyMixins(AngularFireAnalytics, [proxyPolyfillCompat]);\nlet UserTrackingService = /*#__PURE__*/(() => {\n  class UserTrackingService {\n    // TODO a user properties injector\n    constructor(analytics, // tslint:disable-next-line:ban-types\n    platformId, auth, zone) {\n      this.disposables = [];\n      firebase.registerVersion('angularfire', VERSION.full, 'compat-user-tracking');\n\n      if (!isPlatformServer(platformId)) {\n        let resolveInitialized;\n        this.initialized = zone.runOutsideAngular(() => new Promise(resolve => resolveInitialized = resolve));\n        this.disposables = [auth.authState.subscribe(user => {\n          analytics.setUserId(user === null || user === void 0 ? void 0 : user.uid);\n          resolveInitialized();\n        }), auth.credential.subscribe(credential => {\n          if (credential) {\n            const method = credential.user.isAnonymous ? 'anonymous' : credential.additionalUserInfo.providerId;\n\n            if (credential.additionalUserInfo.isNewUser) {\n              analytics.logEvent('sign_up', {\n                method\n              });\n            }\n\n            analytics.logEvent('login', {\n              method\n            });\n          }\n        })];\n      } else {\n        this.initialized = Promise.resolve();\n      }\n    }\n\n    ngOnDestroy() {\n      this.disposables.forEach(it => it.unsubscribe());\n    }\n\n  }\n\n  UserTrackingService.ɵfac = function UserTrackingService_Factory(t) {\n    return new (t || UserTrackingService)(i0.ɵɵinject(AngularFireAnalytics), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i2$1.AngularFireAuth), i0.ɵɵinject(i0.NgZone));\n  };\n\n  UserTrackingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UserTrackingService,\n    factory: UserTrackingService.ɵfac\n  });\n  return UserTrackingService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst SCREEN_VIEW_EVENT = 'screen_view';\nlet ScreenTrackingService = /*#__PURE__*/(() => {\n  class ScreenTrackingService {\n    constructor(analytics, router, title, componentFactoryResolver, zone, userTrackingService) {\n      firebase.registerVersion('angularfire', VERSION.full, 'compat-screen-tracking');\n\n      if (!router || !analytics) {\n        return this;\n      }\n\n      zone.runOutsideAngular(() => {\n        this.disposable = ɵscreenViewEvent(router, title, componentFactoryResolver).pipe(switchMap(params => __awaiter(this, void 0, void 0, function* () {\n          if (userTrackingService) {\n            yield userTrackingService.initialized;\n          }\n\n          return yield analytics.logEvent(SCREEN_VIEW_EVENT, params);\n        }))).subscribe();\n      });\n    }\n\n    ngOnDestroy() {\n      if (this.disposable) {\n        this.disposable.unsubscribe();\n      }\n    }\n\n  }\n\n  ScreenTrackingService.ɵfac = function ScreenTrackingService_Factory(t) {\n    return new (t || ScreenTrackingService)(i0.ɵɵinject(AngularFireAnalytics), i0.ɵɵinject(i2$2.Router, 8), i0.ɵɵinject(i3.Title, 8), i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(UserTrackingService, 8));\n  };\n\n  ScreenTrackingService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScreenTrackingService,\n    factory: ScreenTrackingService.ɵfac\n  });\n  return ScreenTrackingService;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet AngularFireAnalyticsModule = /*#__PURE__*/(() => {\n  class AngularFireAnalyticsModule {\n    constructor(analytics, screenTracking, userTracking) {\n      firebase.registerVersion('angularfire', VERSION.full, 'analytics-compat'); // calling anything on analytics will eagerly load the SDK\n      // tslint:disable-next-line:no-unused-expression\n\n      analytics.app.then(() => {});\n    }\n\n  }\n\n  AngularFireAnalyticsModule.ɵfac = function AngularFireAnalyticsModule_Factory(t) {\n    return new (t || AngularFireAnalyticsModule)(i0.ɵɵinject(AngularFireAnalytics), i0.ɵɵinject(ScreenTrackingService, 8), i0.ɵɵinject(UserTrackingService, 8));\n  };\n\n  AngularFireAnalyticsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireAnalyticsModule\n  });\n  AngularFireAnalyticsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireAnalytics]\n  });\n  return AngularFireAnalyticsModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { APP_NAME, APP_VERSION, AngularFireAnalytics, AngularFireAnalyticsModule, COLLECTION_ENABLED, CONFIG, DEBUG_MODE, ScreenTrackingService, UserTrackingService }; //# sourceMappingURL=angular-fire-compat-analytics.js.map","map":null,"metadata":{},"sourceType":"module"}